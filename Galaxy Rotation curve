import openpyxl
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import statistics
from galpy.potential import MWPotential2014, vcirc
#from galpy.util import bovy_conversion
from galpy.orbit import Orbit
import astropy.units as u



file_location = "Table1.xlsx"
df = pd.read_excel(file_location,sheet_name='Sheet1', usecols="H")
df2 = pd.read_excel(file_location,sheet_name='Sheet1', usecols="H,A")
df3 = pd.read_excel(file_location,sheet_name = 'Sheet1', usecols = "L,A")

df3Array = df3.to_numpy()
print(type(df3Array))

array = df.to_numpy() #converts the dataframe to an array 
mass = (array * (1*(10**9)))*0.6 #obtains the mass from the luminosity

#hist, bins, _ = plt.hist(mass, bins=8)
#logbins = np.logspace(np.log10(bins[0]),np.log10(bins[-1]),len(bins))
#lt.hist(mass, bins = logbins) #plots the histogram for the galaxy masses.
#plt.xscale('log')
#plt.xlabel("Masses of galaxies")
#plt.title("Distribution of the galaxies by mass")
#plt.show()
def galaxy_separation(array):
    high_mass = []
    super_high_mass = []
    low_mass = []
    for each in mass: 
        if each < (5*(10**8)):                      #Identifies the low mass galaxies and appends to a separate list 
            low_mass.append(each)
        elif  (1*(10**11)) > each > (1*(10**10)):   #identifies the high mass galaxies and appends to a separate list
            high_mass.append(each) 
        elif each > (1*(10**11)): 
            super_high_mass.append(each)

    low_mass2 = np.array(low_mass) #converts list to an array
    low_mass2 = np.sort(low_mass2, axis = 0)
    chunks1 = np.array_split(low_mass2, 4)

    high_mass2 = np.array(high_mass) #converts list to an array
    high_mass2 = np.sort(high_mass2, axis = 0)
    chunks2 = np.array_split(high_mass2, 5)
    
    super_high_mass2 = np.array(super_high_mass)
    super_high_mass2 = np.sort(super_high_mass2, axis = 0)
    chunks3 = np.array_split(super_high_mass2, 2)
    return chunks1, chunks2, chunks3, low_mass2, high_mass2, super_high_mass2



def high_mass_galaxy(array):
    
    mass_to_light = (array/0.6)/(1*(10**9)) #reverse the mass back to luminosity for comparison to identify the names.
    array2 = df2.to_numpy() #converts the dataframe to an array
    galaxy = []

    for item in array2: #retrieves the name and luminosity of the stars in accordance with the high mass galaxies
        if item in mass_to_light:
            galaxy.append(item)

    galaxy_name = []
    for each in galaxy: # retrieves the galaxy name only 
        galaxy_name.append(each[0])

    discLength = []
    for each in galaxy_name:
        if each in df3Array:
            discLength.append(each)

    return galaxy_name

def galaxy_data(file_name):  #Created a function to retrieve the data from the RodMod_LTG folder for the relevant high mass galaxy to produce rotation curves.
    folder_path = '/cosma/home/durham/dc-pand2/Rodmod_LTG'
    file_path = os.path.join(folder_path, file_name)
    data = pd.read_csv(file_path, delimiter = '\t')
    array_data = np.loadtxt(file_path)
    Radius = []
    velocity = []
    V_gas = []
    V_disk = []
    V_bulge = []
    for each in array_data:
        Radius.append(each[0])
        velocity.append(each[1])
        V_gas.append(each[3])
        V_disk.append(each[4])
        V_bulge.append(each[5])
    return Radius, velocity, V_gas, V_disk, V_bulge



def RotationCurve(MassArray, GalaxyName, GalaxySection):   #Created a function that plots the data retrieved from the galaxy_data function
    RadiusArray = []
    VelocityArray = []
    RadiusNormalised = []
    VCombined = []
    VBULGE = []
    VDarkMat = []
    for each in MassArray:
        name = each
        extension = '_rotmod.dat'
        file_extension = each + extension
        radius, velocity, VGas, VDisk, VBulge = galaxy_data(file_extension)
        Vbulge = np.array(VBulge)
        Vgas = np.array(VGas)
        Vdisk = np.array(VDisk)
        Velocity = np.array(velocity)
        VBULGE.append(VBulge)                                     #appends the bulge to a list so it can be returned
        VD_G = np.sqrt(Vgas**2 + Vdisk**2)                        #combines the contribution from gas and disk in quadrature
        VCombined.append(VD_G)
        #VDM = np.sqrt((Velocity**2) - ((Vbulge**2) + (VD_G**2)))  #calculate the dark matter halo in quadrature
        #VDarkMat.append(VDM)
        radius2 = np.array(radius, dtype=np.float64)
        if each in df3Array:
            value = np.where(df3Array == each)
            disc = df3Array[value[0],1]                           #identifies the disk scale length to be used in normalisation
        radiusNormalised = radius/disc
        RadiusNormalised.append(radiusNormalised)
        RadiusArray.append(radius2)
        VelocityArray.append(velocity)

        #plot the rotation curve for each galaxy in the array
        #plt.plot(radius, velocity, label = each)
        #plt.xlabel("Radius(kpc)")
        #plt.ylabel("V(km/s)")
        #plt.legend(loc=1, prop={'size': 6})

        #plots the normalised rotation curve for each galaxy in the array
        #plt.plot(radiusNormalised, velocity, label = each)
        #plt.xlabel("($R / R_d$)")
        #plt.ylabel("V (km/s)")
        #plt.legend(loc=1, prop={'size': 6})


        
        #identifies which part of the galaxy needs plotting (disk, bulge, dark matter) or the whole rotation curve
        if GalaxySection == "VB":
            plt.plot(radius, VBulge, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
        elif GalaxySection == "VDB": 
            plt.plot(radius, VD_G, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
        elif GalaxySection == "VDM":
            plt.plot(radius, V, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
        else:
            plt.plot(radius, velocity, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
            
        
        
    #plt.figure()
    
    return RadiusArray, VelocityArray, RadiusNormalised, VBULGE, VCombined#, VDarkMat



def AverageFunction(InitialValues, Radius, Velocity, bin_size):
    selected_velocities_by_range = [[] for _ in range(len(InitialValues) - 1)]

    # Iterate over each range defined by consecutive values in the ranges array
    for k in range(len(InitialValues) - 1):
        lower_bound = InitialValues[k]
        upper_bound = InitialValues[k + 1]

        # Iterate over elements in the radius array
        for i in range(len(Radius)):
            for j in range(len(Radius[i])):
                # Check if the radius value falls within the current range
                if lower_bound <= Radius[i][j] < upper_bound:
                    # Append the corresponding velocity value to the list for the current range
                    selected_velocities_by_range[k].append(Velocity[i][j])               

    # List to store the average velocity for each range
    average_velocities = []
    std_devs = []

    # Calculate the average for each range
    for velocities in selected_velocities_by_range:
        if velocities:  # Check if the list is not empty to avoid division by zero
            average = sum(velocities) / len(velocities)
            std_dev = statistics.stdev(velocities) if len(velocities) > 1 else 0
        
        average_velocities.append(average)
        std_devs.append(std_dev)
        
    upper_bound = [avg + sd for avg, sd in zip(average_velocities, std_devs)]
    lower_bound = [avg - sd for avg, sd in zip(average_velocities, std_devs)]
    
    
    
    return average_velocities, std_devs, upper_bound, lower_bound   
                
    


def AverageFunctionPlotting(GalaxyMass, bin_size, maxPlus, GalaxySection):
    x = high_mass_galaxy(GalaxyMass)
    R, V, RN, VB, VDB = RotationCurve(x, " ", GalaxySection)
    #Runs a selection statement to correctly use the right aspect of the galaxy for the averaging.
    if GalaxySection == "VB":
        x_ticks = plt.gca().get_xticks()
        X_ticks = np.delete( x_ticks, -1)
        maxValue = np.max(X_ticks)
        radius = np.linspace(0, maxValue + maxPlus, bin_size)
        bin_size = radius[1] - radius[0]
        val, stddev, up, down = AverageFunction(radius, R, VB, bin_size)
    elif GalaxySection == "VDB":
        x_ticks = plt.gca().get_xticks()
        X_ticks = np.delete( x_ticks, -1)
        maxValue = np.max(X_ticks)
        radius = np.linspace(0, maxValue + maxPlus, bin_size)
        bin_size = radius[1] - radius[0]
        val, stddev, up, down = AverageFunction(radius, R, VDB, bin_size)
    #elif GalaxySection == "VDM":
    #    x_ticks = plt.gca().get_xticks()
    #    X_ticks = np.delete( x_ticks, -1)
    #    maxValue = np.max(X_ticks)
    #    radius = np.linspace(0, maxValue + maxPlus, bin_size)
    #    bin_size = radius[1] - radius[0]
    #    val, stddev, up, down = AverageFunction(radius, R, VDM, bin_size)
    else:
        x_ticks = plt.gca().get_xticks()
        X_ticks = np.delete( x_ticks, -1)
        maxValue = np.max(X_ticks)
        radius = np.linspace(0, maxValue + maxPlus, bin_size)
        bin_size = radius[1] - radius[0]
        val, stddev, up, down = AverageFunction(radius, R, V, bin_size)
        
    return val, radius, stddev, up, down


def DarkMatterCalculate(Total, DiskGas, Bulge, TotalStdev, DiskGasStdDev, BulgeStdev):
    v_total = np.array(Total)       # Total rotation curve
    v_bulge = np.array(Bulge)       # Bulge rotation curve
    v_disk_gas = np.array(DiskGas)    # Disk + gas rotation curve
    sigma_total = np.array(TotalStdev)   # Uncertainty in total rotation
    sigma_bulge = np.array(BulgeStdev)   # Uncertainty in bulge rotation
    sigma_disk_gas = np.array(DiskGasStdDev) # Uncertainty in disk + gas rotation

    # Calculate dark matter rotation curve
    v_DM_squared = v_total**2 - v_bulge**2 - v_disk_gas**2
    v_DM = np.sqrt(np.maximum(v_DM_squared, 0))  # Set negative values to zero to avoid NaN

    # Calculate the standard deviation of the dark matter component
    sigma_v_DM_squared = np.sqrt(
        (2 * v_total * sigma_total)**2 +
        (2 * v_bulge * sigma_bulge)**2 +
        (2 * v_disk_gas * sigma_disk_gas)**2
    )
    with np.errstate(divide='ignore', invalid='ignore'):
        sigma_DM = np.where(v_DM > 0, sigma_v_DM_squared / (2 * v_DM), np.nan)

    return v_DM, sigma_DM



LowMass, MediumMass, HighMass, LowMass2, MediumMass2, HighMass2 = galaxy_separation(mass)

'''for each in HighMass:
    average, radius, stddev, upper, lower = AverageFunctionPlotting(each, 20, 14)
    radius = np.delete(radius, -1)
    plt.plot(radius, average, color = "black" ,label = "Average")
    plt.scatter(radius, average, s = 7 ,color = "black" ,label = "Average")
    plt.legend(bbox_to_anchor=(1.0, 1.0),prop={'size': 7} ,loc='upper left')
    plt.fill_between(radius, upper, lower, color="grey",alpha=0.4)
    plt.figure()'''

plt.figure()
average1, radius1, stddev1 ,upper1, lower1 = AverageFunctionPlotting(HighMass2, 25, 13, "VB")
radius1 = np.delete(radius1, -1)
plt.plot(radius1,average1, color = "black",label = "Average")
plt.scatter(radius1, average1, s = 7, color = "black")
plt.fill_between(radius1, upper1, lower1, color="grey",alpha=0.4)
plt.title("Bulge velocity curves")

average2, radius2, stddev2 ,upper2, lower2 = AverageFunctionPlotting(HighMass2, 25, 13, "VDB")
radius2 = np.delete(radius2, -1)
plt.plot(radius2,average2, color = "black",label = "Average")
plt.scatter(radius2, average2, s = 7, color = "black")
plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)
plt.title("Disk + gas velocity curves")


average4, radius4, stddev4 ,upper4, lower4 = AverageFunctionPlotting(HighMass2, 25, 13, "")
radius4 = np.delete(radius4, -1)
plt.plot(radius4, average4, color = "black",label = "Total")
plt.scatter(radius4, average4, s = 7, color = "black")
plt.fill_between(radius4, upper4, lower4, color="grey",alpha=0.4)
plt.title(" Total rotaion curves curves")




DMHigh, DMStdevHigh = DarkMatterCalculate(averageHigh4, averageHigh2, averageHigh, stddevHigh4, stddevHigh2, stddevHigh)
DMMedium, DMStdevMedium = DarkMatterCalculate(averageMedium4, averageMedium2, averageMedium, stddevMedium4, stddevMedium2, stddevMedium)
DMLow, DMStdevLow = DarkMatterCalculate(averageLow4, averageLow2, averageLow, stddevLow4, stddevLow2, stddevLow)
    

plt.figure()
plt.title("High mass")
plt.xlabel("Radius(kpc)")
plt.ylabel("Velocity (km/s)")

plt.plot(radius1,average1, color = "blue",label = "Bulge")
plt.scatter(radius1, average1, s = 7, color = "blue")
plt.fill_between(radius1, upper1, lower1, color="blue",alpha=0.4)

plt.plot(radius2,average2, color = "black",label = "Disk + gas")
plt.scatter(radius2, average2, s = 7, color = "black")
plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)

plt.plot(radius4, average4, color = "brown",label = "Total")
plt.scatter(radius4, average4, s = 7, color = "brown")
plt.fill_between(radius4, upper4, lower4, color="brown",alpha=0.4)


plt.plot(radius4, DMHigh, color = "purple",label = "Total")
plt.scatter(radius4, DMHigh, s = 7, color = "purple")
plt.fill_between(radius4, DMHigh + DMStdevHigh, DMHigh - DMStdevHigh, color="purple",alpha=0.4)











'''plt.figure()
plotRotcurve(mwp14, ro = 10.0, vo = 235.0, color = "Blue",label = "Milky Way")
plt.xlim(left=-1)
#plt.yticks([0, 50, 100, 150, 200, 250, 300, 350, 400])
plt.xticks([0, 10, 20, 30, 40, 50])
average2, radius2, stddev ,upper2, lower2 = AverageFunctionPlotting(MediumMass[3], 23, 10, "")
radius2 = np.delete(radius2, -1)
plt.plot(radius2,average2, color = "black",label = "Average")
plt.scatter(radius2, average2, s = 7 ,color = 'black' ,label = "Average")
plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)'''



'''plt.figure()
average3, radius3, stddev ,upper3, lower3 = AverageFunctionPlotting(LowMass2, 15, 2)
radius3 = np.delete(radius3, -1)
plt.plot(radius3,average3, color = "black",label = "Average")
plt.scatter(radius3, average3, s = 7 ,color = 'black' ,label = "Average")
plt.fill_between(radius3, upper3, lower3, color="grey",alpha=0.4)'''


plt.legend(bbox_to_anchor=(1.0, 1.0),prop={'size': 6}, ncol =1 ,loc='upper left')

'''Rrange = np.linspace(0, 110,10)
plt.figure()
plotRotcurve(mwp14, ro = 20.0, vo = 235.0, label = "Milky Way")
plt.xlim(left=-1)
plt.yticks([0, 50, 100, 150, 200, 250, 300, 350, 400])
plt.xticks([0, 20, 40, 60, 80, 100, 120])
plt.plot(radius1,average1, color = "Red",label = "High mass")
plt.scatter(radius1, average1, s = 7 ,color = 'Red' )#,label = "High mass")
plt.fill_between(radius1, upper1, lower1, color="grey",alpha=0.4)
plt.plot(radius2,average2, color = "Green",label = "Medium mass")
plt.scatter(radius2, average2, s = 7 ,color = 'Green' )#,label = "Medium mass")
plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)
plt.plot(radius3,average3, color = "Orange",label = "Low mass")
plt.scatter(radius3, average3, s = 7 ,color = 'Orange' )#,label = "Low mass")
plt.fill_between(radius3, upper3, lower3, color="grey",alpha=0.4)
plt.legend()'''



plt.show()
