import openpyxl
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import statistics
from galpy.potential import MWPotential2014, vcirc
#from galpy.util import bovy_conversion
from galpy.orbit import Orbit
import astropy.units as u
from astropy.io import ascii



file_location = "Maximum disk galaxy data.xlsx"
df = pd.read_excel(file_location,sheet_name='Sheet1', usecols="B") #mass values from excel
df3 = pd.read_excel(file_location,sheet_name = 'Sheet1', usecols = "A, B") # mass + names of the galaxies
df4 = pd.read_excel(file_location,sheet_name = 'Sheet1', usecols = "A,B,R") # mass + names + disk scale of galaxies

mass = df.to_numpy()
MassNames = df3.to_numpy()
MassDiskScale = df4.to_numpy()
#print(mass)




#hist, bins, _ = plt.hist(mass, bins=8)
#logbins = np.logspace(np.log10(bins[0]),np.log10(bins[-1]),len(bins))
#lt.hist(mass, bins = logbins) #plots the histogram for the galaxy masses.
#plt.xscale('log')
#plt.xlabel("Masses of galaxies")
#plt.title("Distribution of the galaxies by mass")
#plt.show()
def galaxy_separation(array):
    medium_mass = []
    high_mass = []
    super_high_mass = []
    low_mass = []
    for each in mass: 
        if each < (5*(10**9)):                      #Identifies the low mass galaxies and appends to a separate list 
            low_mass.append(each)
        elif  (1*(10**11)) > each > (1*(10**10)):   #identifies the high mass galaxies and appends to a separate list
            medium_mass.append(each) 
        elif (1*(10**12)) > each > (1*(10**11)): 
            high_mass.append(each)
        elif each > (1*(10**12)):
            super_high_mass.append(each)
            

    low_mass2 = np.array(low_mass) #converts list to an array
    low_mass2 = np.sort(low_mass2, axis = 0)
    chunks1 = np.array_split(low_mass2, 4)

    
    medium_mass2 = np.array(medium_mass) #converts list to an array
    medium_mass2 = np.sort(medium_mass2, axis = 0)
    chunks2 = np.array_split(medium_mass2, 4)

    high_mass2 = np.array(high_mass) #converts list to an array
    high_mass2 = np.sort(high_mass2, axis = 0)
    chunks3 = np.array_split(high_mass2, 5)
    
    super_high_mass2 = np.array(super_high_mass)
    super_high_mass2 = np.sort(super_high_mass2, axis = 0)
    chunks4 = np.array_split(super_high_mass2, 2)
    return chunks1,chunks2 ,chunks3, chunks4, low_mass2,  medium_mass2, high_mass2, super_high_mass2



def high_mass_galaxy(array):
    
    #mass_to_light = (array/0.6)/(1*(10**9) #reverse the mass back to luminosity for comparison to identify the names.
    #array2 = df2.to_numpy() #converts the dataframe to an array
    galaxy = []

    for item in MassNames: #retrieves the name and luminosity of the stars in accordance with the galaxies
        if item in array:
            galaxy.append(item)

    galaxy_name = []
    for each in galaxy: # retrieves the galaxy name only 
        galaxy_name.append(each[0])

    discLength = []
    for each in galaxy_name:
        if each in df3Array:
            discLength.append(each)

    return galaxy_name

def galaxy_data(file_name):  #Created a function to retrieve the data from the RodMod_LTG folder for the relevant high mass galaxy to produce rotation curves.
    folder_path = '/cosma/home/durham/dc-pand2'
    file_path = os.path.join(folder_path, file_name)
    data = pd.read_csv(file_path ,delimiter = "\t")
    array_data = np.loadtxt(file_path)
    Radius = []
    velocity = []
    V_gas = []
    V_disk = []
    V_bulge = []
    for each in array_data:
        Radius.append(each[0])
        velocity.append(each[1])
        V_gas.append(each[3])
        V_disk.append(each[4])
        V_bulge.append(each[7])
    return Radius, velocity, V_gas, V_disk, V_bulge



def RotationCurve(MassArray, GalaxyName, GalaxySection):   #Created a function that plots the data retrieved from the galaxy_data function
    RadiusArray = []
    VelocityArray = []
    RadiusNormalised = []
    VCombined = []
    VGas = []
    VDarkMat = []
    for each in MassArray:
        name = each
        extension = '.txt'
        file_extension = each + extension
        radius, velocity, VGas, VDisk, VBulge = galaxy_data(file_extension)
        Vbulge = np.array(VBulge)
        Vgas = np.array(VGas)
        Vdisk = np.array(VDisk)
        Velocity = np.array(velocity)
        VGas.append(Vgas)                                     #appends the bulge to a list so it can be returned
        VD_G = np.sqrt(Vbulge**2 + Vdisk**2)                        #combines the contribution from gas and disk in quadrature
        VCombined.append(VD_G)
        #VDM = np.sqrt((Velocity**2) - ((Vbulge**2) + (VD_G**2)))  #calculate the dark matter halo in quadrature
        #VDarkMat.append(VDM)
        radius2 = np.array(radius, dtype=np.float64)
        if each in MassDiskScale:
            value = np.where(MassDiskScale == each)
            disc = MassDiskScale[value[0],2]                           #identifies the disk scale length to be used in normalisation
        radiusNormalised = radius/disc
        RadiusNormalised.append(radiusNormalised)
        RadiusArray.append(radius2)
        VelocityArray.append(velocity)

        #plot the rotation curve for each galaxy in the array
        plt.plot(radius, velocity, label = each)
        plt.xlabel("Radius(kpc)")
        plt.ylabel("V(km/s)")
        #plt.legend(loc=1, prop={'size': 6})

        #plots the normalised rotation curve for each galaxy in the array
        #plt.plot(radiusNormalised, velocity, label = each)
        #plt.xlabel("($R / R_d$)")
        #plt.ylabel("V (km/s)")
        #plt.legend(loc=1, prop={'size': 6})


        
        #identifies which part of the galaxy needs plotting (disk, bulge, dark matter) or the whole rotation curve
        if GalaxySection == "VB":
            plt.plot(radius, VBulge, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
        elif GalaxySection == "VDB": 
            plt.plot(radius, VD_G, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
        elif GalaxySection == "VDM":
            plt.plot(radius, V, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
        else:
            plt.plot(radius, velocity, label = each)
            plt.xlabel("Radius(kpc)")
            plt.ylabel("V(km/s)")
            
        
        
    #plt.figure()
    
    return RadiusArray, VelocityArray, RadiusNormalised, VGas, VCombined#, VDarkMat



def AverageFunction(InitialValues, Radius, Velocity, bin_size):
    selected_velocities_by_range = [[] for _ in range(len(InitialValues) - 1)]

    # Iterate over each range defined by consecutive values in the ranges array
    for k in range(len(InitialValues) - 1):
        lower_bound = InitialValues[k]
        upper_bound = InitialValues[k + 1]

        # Iterate over elements in the radius array
        for i in range(len(Radius)):
            for j in range(len(Radius[i])):
                # Check if the radius value falls within the current range
                if lower_bound <= Radius[i][j] < upper_bound:
                    # Append the corresponding velocity value to the list for the current range
                    selected_velocities_by_range[k].append(Velocity[i][j])               

    # List to store the average velocity for each range
    average_velocities = []
    std_devs = []

    # Calculate the average for each range
    for velocities in selected_velocities_by_range:
        if velocities:  # Check if the list is not empty to avoid division by zero
            average = sum(velocities) / len(velocities)
            std_dev = statistics.stdev(velocities) if len(velocities) > 1 else 0
        
        average_velocities.append(average)
        std_devs.append(std_dev)
        
    upper_bound = [avg + sd for avg, sd in zip(average_velocities, std_devs)]
    lower_bound = [avg - sd for avg, sd in zip(average_velocities, std_devs)]
    
    
    
    return average_velocities, std_devs, upper_bound, lower_bound   
                
    


def AverageFunctionPlotting(GalaxyMass, bin_size, maxPlus, GalaxySection):
    x = high_mass_galaxy(GalaxyMass)
    R, V, RN, VB, VDB = RotationCurve(x, " ", GalaxySection)
    #Runs a selection statement to correctly use the right aspect of the galaxy for the averaging.
    if GalaxySection == "VB":
        x_ticks = plt.gca().get_xticks()
        X_ticks = np.delete( x_ticks, -1)
        maxValue = np.max(X_ticks)
        radius = np.linspace(0, maxValue + maxPlus, bin_size)
        bin_size = radius[1] - radius[0]
        val, stddev, up, down = AverageFunction(radius, R, VB, bin_size)
    elif GalaxySection == "VDB":
        x_ticks = plt.gca().get_xticks()
        X_ticks = np.delete( x_ticks, -1)
        maxValue = np.max(X_ticks)
        radius = np.linspace(0, maxValue + maxPlus, bin_size)
        bin_size = radius[1] - radius[0]
        val, stddev, up, down = AverageFunction(radius, R, VDB, bin_size)
    else:
        x_ticks = plt.gca().get_xticks()
        X_ticks = np.delete( x_ticks, -1)
        maxValue = np.max(X_ticks)
        radius = np.linspace(0, maxValue + maxPlus, bin_size)
        bin_size = radius[1] - radius[0]
        val, stddev, up, down = AverageFunction(radius, R, V, bin_size)
        
    return val, radius, stddev, up, down


def DarkMatterCalculate(Total, DiskGas, Bulge, TotalStdev, DiskGasStdDev, BulgeStdev):
    v_total = np.array(Total)       # Total rotation curve
    v_bulge = np.array(Bulge)       # Bulge rotation curve
    v_disk_gas = np.array(DiskGas)    # Disk + gas rotation curve
    sigma_total = np.array(TotalStdev)   # Uncertainty in total rotation
    sigma_bulge = np.array(BulgeStdev)   # Uncertainty in bulge rotation
    sigma_disk_gas = np.array(DiskGasStdDev) # Uncertainty in disk + gas rotation

    # Calculate dark matter rotation curve
    v_DM_squared = v_total**2 - v_bulge**2 - v_disk_gas**2
    v_DM = np.sqrt(np.maximum(v_DM_squared, 0))  # Set negative values to zero to avoid NaN

    # Calculate the standard deviation of the dark matter component
    sigma_v_DM_squared = np.sqrt(
        (2 * v_total * sigma_total)**2 +
        (2 * v_bulge * sigma_bulge)**2 +
        (2 * v_disk_gas * sigma_disk_gas)**2
    )
    with np.errstate(divide='ignore', invalid='ignore'):
        sigma_DM = np.where(v_DM > 0, sigma_v_DM_squared / (2 * v_DM), np.nan)

    return v_DM, sigma_DM



LowMass, MediumMass, HighMass, SuperHighMass, LowMass2, MediumMass2, HighMass2, SuperHighMass2 = galaxy_separation(mass)

'''for each in HighMass:
    average, radius, stddev, upper, lower = AverageFunctionPlotting(each, 20, 14)
    radius = np.delete(radius, -1)
    plt.plot(radius, average, color = "black" ,label = "Average")
    plt.scatter(radius, average, s = 7 ,color = "black" ,label = "Average")
    plt.legend(bbox_to_anchor=(1.0, 1.0),prop={'size': 7} ,loc='upper left')
    plt.fill_between(radius, upper, lower, color="grey",alpha=0.4)
    plt.figure()'''



plt.figure()
average1, radius1, stddev1 ,upper1, lower1 = AverageFunctionPlotting(SuperHighMass2, 20, 10, "")
radius1 = np.delete(radius1, -1)
plt.plot(radius1,average1, color = "black",label = "Average")
plt.scatter(radius1, average1, s = 7, color = "black")
plt.fill_between(radius1, upper1, lower1, color="grey",alpha=0.4)
plt.legend()
handles, labels = plt.gca().get_legend_handles_labels()  
lgd = dict(zip(labels, handles))
plt.legend(lgd.values(), lgd.keys(),bbox_to_anchor=(1.0, 1.0),prop={'size': 6}, ncol =1 ,loc='upper left')


def RotationCurveBreakDownPlot(MassType, Bin_size, Extension):
    plt.figure()
    average1, radius1, stddev1 ,upper1, lower1 = AverageFunctionPlotting(MassType, Bin_size, Extension, "VB")
    radius1 = np.delete(radius1, -1)
    plt.plot(radius1,average1, color = "black",label = "Average")
    plt.scatter(radius1, average1, s = 7, color = "black")
    plt.fill_between(radius1, upper1, lower1, color="grey",alpha=0.4)
    plt.title("Bulge velocity curves")

    plt.figure()
    average2, radius2, stddev2 ,upper2, lower2 = AverageFunctionPlotting(MassType, Bin_size, Extension, "VDB")
    radius2 = np.delete(radius2, -1)
    plt.plot(radius2,average2, color = "black",label = "Average")
    plt.scatter(radius2, average2, s = 7, color = "black")
    plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)
    plt.title("Disk + gas velocity curves")


    plt.figure()
    average4, radius4, stddev4 ,upper4, lower4 = AverageFunctionPlotting(MassType, Bin_size, Extension, "")
    radius4 = np.delete(radius4, -1)
    plt.plot(radius4, average4, color = "black",label = "Total")
    plt.scatter(radius4, average4, s = 7, color = "black")
    plt.fill_between(radius4, upper4, lower4, color="grey",alpha=0.4)
    plt.title(" Total rotaion curves curves")

    
    DM, DMStdev = DarkMatterCalculate(average4, average2, average1, stddev4, stddev2, stddev1)

    
    plt.figure()
    plt.title("Medium mass")
    plt.xlabel("Radius(kpc)")
    plt.ylabel("Velocity (km/s)")

    plt.plot(radius1,average1, color = "blue",label = "Bulge")
    plt.scatter(radius1, average1, s = 7, color = "blue")
    plt.fill_between(radius1, upper1, lower1, color="blue",alpha=0.4)

    plt.plot(radius2,average2, color = "black",label = "Disk + gas")
    plt.scatter(radius2, average2, s = 7, color = "black")
    plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)

    plt.plot(radius4, average4, color = "brown",label = "Total")
    plt.scatter(radius4, average4, s = 7, color = "brown")
    plt.fill_between(radius4, upper4, lower4, color="brown",alpha=0.4)

    plt.plot(radius4, DM, color = "purple",label = "Dark Matter")
    plt.scatter(radius4, DM, s = 7, color = "purple")
    plt.fill_between(radius4, DM + DMStdev, DM - DMStdev, color="purple",alpha=0.4)


    return radius1, radius2, radius4, average1, average2, average4, DM, upper1, lower1, upper2, lower2, upper4, lower4, DMStdev



'''R1, R2, R4, A1, A2, A4, DM, U1, L1, U2, L2, U4, L4, DMStd = RotationCurveBreakDownPlot(HighMass2, 25, 13)
RM1, RM2, RM4, AM1, AM2, AM4, DMM, UM1, LM1, UM2, LM2, UM4, LM4, DMMStd = RotationCurveBreakDownPlot(MediumMass2, 25, 10)
RL1, RL2, RL4, AL1, AL2, AL4, DLM, UL1, LL1, UL2, LL2, UL4, LL4, DMLStd = RotationCurveBreakDownPlot(LowMass2, 15, 2)'''
'''plt.figure()
plt.subplot(2,2,1)
plt.title("High mass")
plt.plot(R1,A1, color = "blue",label = "Bulge")
plt.scatter(R1, A1, s = 7, color = "blue")
plt.fill_between(R1, U1, L1, color="blue",alpha=0.4)

plt.plot(R2, A2, color = "black",label = "Disk + gas")
plt.scatter(R2, A2, s = 7, color = "black")
plt.fill_between(R2, U2, L2, color="grey",alpha=0.4)

plt.plot(R4, A4, color = "brown",label = "Total")
plt.scatter(R4, A4, s = 7, color = "brown")
plt.fill_between(R4, U4, L4, color="brown",alpha=0.4)

plt.plot(R4, DM, color = "purple",label = "Dark Matter")
plt.scatter(R4, DM, s = 7, color = "purple")
plt.fill_between(R4, DM + DMStd, DM - DMStd, color="purple",alpha=0.4)


plt.subplot(2,2,2)
plt.title("Medium mass")
plt.plot(RM1,AM1, color = "blue",label = "Bulge")
plt.scatter(RM1, AM1, s = 7, color = "blue")
plt.fill_between(RM1, UM1, LM1, color="blue",alpha=0.4)

plt.plot(RM2, AM2, color = "black",label = "Disk + gas")
plt.scatter(RM2, AM2, s = 7, color = "black")
plt.fill_between(RM2, UM2, LM2, color="grey",alpha=0.4)

plt.plot(RM4, AM4, color = "brown",label = "Total")
plt.scatter(RM4, AM4, s = 7, color = "brown")
plt.fill_between(RM4, UM4, LM4, color="brown",alpha=0.4)

plt.plot(RM4, DMM, color = "purple",label = "Dark Matter")
plt.scatter(RM4, DMM, s = 7, color = "purple")
plt.fill_between(RM4, DMM + DMMStd, DMM - DMMStd, color="purple",alpha=0.4)


plt.subplot(2,2,3)
plt.title("Low mass")
plt.plot(RL1,AL1, color = "blue",label = "Bulge")
plt.scatter(RL1, AL1, s = 7, color = "blue")
plt.fill_between(RL1, UL1, LL1, color="blue",alpha=0.4)

plt.plot(RL2, AL2, color = "black",label = "Disk + gas")
plt.scatter(RL2, AL2, s = 7, color = "black")
plt.fill_between(RL2, UL2, LL2, color="grey",alpha=0.4)

plt.plot(RL4, AL4, color = "brown",label = "Total")
plt.scatter(RL4, AL4, s = 7, color = "brown")
plt.fill_between(RL4, UL4, LL4, color="brown",alpha=0.4)

plt.plot(RL4, DLM, color = "purple",label = "Dark Matter")
plt.scatter(RL4, DLM, s = 7, color = "purple")
plt.fill_between(RL4, DLM + DMLStd, DLM - DMLStd, color="purple",alpha=0.4)
plt.tight_layout()'''






'''plt.figure()
plotRotcurve(mwp14, ro = 10.0, vo = 235.0, color = "Blue",label = "Milky Way")
plt.xlim(left=-1)
#plt.yticks([0, 50, 100, 150, 200, 250, 300, 350, 400])
plt.xticks([0, 10, 20, 30, 40, 50])
average2, radius2, stddev ,upper2, lower2 = AverageFunctionPlotting(MediumMass[3], 23, 10, "")
radius2 = np.delete(radius2, -1)
plt.plot(radius2,average2, color = "black",label = "Average")
plt.scatter(radius2, average2, s = 7 ,color = 'black' ,label = "Average")
plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)'''



'''plt.figure()
average3, radius3, stddev ,upper3, lower3 = AverageFunctionPlotting(LowMass2, 15, 2)
radius3 = np.delete(radius3, -1)
plt.plot(radius3,average3, color = "black",label = "Average")
plt.scatter(radius3, average3, s = 7 ,color = 'black' ,label = "Average")
plt.fill_between(radius3, upper3, lower3, color="grey",alpha=0.4)'''


#plt.legend(bbox_to_anchor=(1.0, 1.0),prop={'size': 6}, ncol =1 ,loc='upper left')

'''Rrange = np.linspace(0, 110,10)
plt.figure()
plotRotcurve(mwp14, ro = 20.0, vo = 235.0, label = "Milky Way")
plt.xlim(left=-1)
plt.yticks([0, 50, 100, 150, 200, 250, 300, 350, 400])
plt.xticks([0, 20, 40, 60, 80, 100, 120])
plt.plot(radius1,average1, color = "Red",label = "High mass")
plt.scatter(radius1, average1, s = 7 ,color = 'Red' )#,label = "High mass")
plt.fill_between(radius1, upper1, lower1, color="grey",alpha=0.4)
plt.plot(radius2,average2, color = "Green",label = "Medium mass")
plt.scatter(radius2, average2, s = 7 ,color = 'Green' )#,label = "Medium mass")
plt.fill_between(radius2, upper2, lower2, color="grey",alpha=0.4)
plt.plot(radius3,average3, color = "Orange",label = "Low mass")
plt.scatter(radius3, average3, s = 7 ,color = 'Orange' )#,label = "Low mass")
plt.fill_between(radius3, upper3, lower3, color="grey",alpha=0.4)
plt.legend()'''



plt.show()
