import openpyxl
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import statistics


file_location = "Table1.xlsx"
df = pd.read_excel(file_location,sheet_name='Sheet1', usecols="H")
df2 = pd.read_excel(file_location,sheet_name='Sheet1', usecols="H,A")
df3 = pd.read_excel(file_location,sheet_name = 'Sheet1', usecols = "L,A")

df3Array = df3.to_numpy()
print(type(df3Array))

array = df.to_numpy() #converts the dataframe to an array 
mass = (array * (1*(10**9)))*0.6 #obtains the mass from the luminosity

#hist, bins, _ = plt.hist(mass, bins=8)
#logbins = np.logspace(np.log10(bins[0]),np.log10(bins[-1]),len(bins))
#lt.hist(mass, bins = logbins) #plots the histogram for the galaxy masses.
#plt.xscale('log')
#plt.xlabel("Masses of galaxies")
#plt.title("Distribution of the galaxies by mass")
#plt.show()
def galaxy_separation(array):
    high_mass = []
    super_high_mass = []
    low_mass = []
    for each in mass: 
        if each < (5*(10**8)):                      #Identifies the low mass galaxies and appends to a separate list 
            low_mass.append(each)
        elif  (1*(10**11)) > each > (1*(10**10)):   #identifies the high mass galaxies and appends to a separate list
            high_mass.append(each) 
        elif each > (1*(10**11)): 
            super_high_mass.append(each)

    low_mass2 = np.array(low_mass) #converts list to an array
    low_mass2 = np.sort(low_mass2, axis = 0)
    chunks1 = np.array_split(low_mass2, 4)

    high_mass2 = np.array(high_mass) #converts list to an array
    high_mass2 = np.sort(high_mass2, axis = 0)
    chunks2 = np.array_split(high_mass2, 5)
    
    super_high_mass2 = np.array(super_high_mass)
    super_high_mass2 = np.sort(super_high_mass2, axis = 0)
    chunks3 = np.array_split(super_high_mass2, 2)
    return chunks1, chunks2, chunks3, low_mass2, high_mass2, super_high_mass2



def high_mass_galaxy(array):
    
    mass_to_light = (array/0.6)/(1*(10**9)) #reverse the mass back to luminosity for comparison to identify the names.
    array2 = df2.to_numpy() #converts the dataframe to an array
    galaxy = []

    for item in array2: #retrieves the name and luminosity of the stars in accordance with the high mass galaxies
        if item in mass_to_light:
            galaxy.append(item)

    galaxy_name = []
    for each in galaxy: # retrieves the galaxy name only 
        galaxy_name.append(each[0])

    discLength = []
    for each in galaxy_name:
        if each in df3Array:
            discLength.append(each)

    return galaxy_name

def galaxy_data(file_name):  #Created a function to retrieve the data from the RodMod_LTG folder for the relevant high mass galaxy to produce rotation curves.
    folder_path = '/cosma/home/durham/dc-pand2/Rodmod_LTG'
    file_path = os.path.join(folder_path, file_name)
    data = pd.read_csv(file_path, delimiter = '\t')
    array_data = np.loadtxt(file_path)
    Radius = []
    velocity = []
    V_gas = []
    V_disk = []
    V_bulge = []
    for each in array_data:
        Radius.append(each[0])
        velocity.append(each[1])
        V_gas.append(each[3])
        V_disk.append(each[4])
        V_bulge.append(each[5])
    return Radius, velocity, V_gas, V_disk, V_bulge



def RotationCurve(MassArray, GalaxyName):   #Created a function that plots the data retrieved from the galaxy_data function
    RadiusArray = []
    VelocityArray = []
    RadiusNormalised = []
    for each in MassArray:
        name = each
        extension = '_rotmod.dat'
        file_extension = each + extension
        radius, velocity, VGas, VDisk, VBulge = galaxy_data(file_extension)
        radius2 = np.array(radius, dtype=np.float64)
        if each in df3Array:
            value = np.where(df3Array == each)
            disc = df3Array[value[0],1]
        radiusNormalised = radius/disc
        RadiusNormalised.append(radiusNormalised)
        RadiusArray.append(radius2)
        VelocityArray.append(velocity)
        #plt.subplot(2,1,1)
        #plt.plot(radius, velocity, label = each)
        #plt.title(GalaxyName)
        #plt.xlabel("Radius(kpc)")
        #plt.ylabel("V(km/s)")
        #plt.tight_layout()
        #plt.legend(loc=1, prop={'size': 6})
        
        
        #plt.plot(radius, VGas, label = each)
        #plt.title(GalaxyName)
        #plt.xlabel("Radius(kpc)")
        #plt.ylabel("V(km/s)")
        
        
        #plt.plot(radius, VDisk, label = each)
        #plt.title(GalaxyName)
        #plt.xlabel("Radius(kpc)")
        #plt.ylabel("V(km/s)")
    
        #plt.plot(radius, VBulge, label = each)
        #plt.title(GalaxyName)
        #plt.xlabel("Radius(kpc)")
        #plt.ylabel("V(km/s)")
        
        
        
        #plt.subplot(2,1,2)
        plt.plot(radiusNormalised, velocity, label = each)
        plt.title(GalaxyName + " Normalised")
        plt.xlabel("($R / R_d$)")
        plt.ylabel("V (km/s)")
        #plt.tight_layout()
        #plt.legend(loc=1, prop={'size': 6})
        
        
    #plt.figure()
    
    return RadiusArray, VelocityArray, RadiusNormalised, VGas#, VDisk, VBulge



def AverageFunction(InitialValues, Radius, Velocity, bin_size):
    selected_velocities_by_range = [[] for _ in range(len(InitialValues) - 1)]

    # Iterate over each range defined by consecutive values in the ranges array
    for k in range(len(InitialValues) - 1):
        lower_bound = InitialValues[k]
        upper_bound = InitialValues[k + 1]

        # Iterate over elements in the radius array
        for i in range(len(Radius)):
            for j in range(len(Radius[i])):
                # Check if the radius value falls within the current range
                if lower_bound <= Radius[i][j] < upper_bound:
                    # Append the corresponding velocity value to the list for the current range
                    selected_velocities_by_range[k].append(Velocity[i][j])
                    


    # List to store the average velocity for each range
    average_velocities = []
    std_devs = []

    # Calculate the average for each range
    for velocities in selected_velocities_by_range:
        if velocities:  # Check if the list is not empty to avoid division by zero
            average = sum(velocities) / len(velocities)
            std_dev = statistics.stdev(velocities) if len(velocities) > 1 else 0
        
        average_velocities.append(average)
        std_devs.append(std_dev)
        
    upper_bound = [avg + sd for avg, sd in zip(average_velocities, std_devs)]
    lower_bound = [avg - sd for avg, sd in zip(average_velocities, std_devs)]
    
    
    
    return average_velocities, std_devs, upper_bound, lower_bound   
                
    


def AverageFunctionPlotting(GalaxyMass, bin_size, maxPlus):
    x = high_mass_galaxy(GalaxyMass)
    R, V, RN, VG = RotationCurve(x, " ")
    x_ticks = plt.gca().get_xticks()
    X_ticks = np.delete( x_ticks, -1)
    maxValue = np.max(X_ticks)
    radius = np.linspace(0, maxValue + maxPlus, bin_size)
    bin_size = radius[1] - radius[0]
    val, stddev, up, down = AverageFunction(radius, RN, V, bin_size)
    return val, radius, stddev, up, down



LowMass, MediumMass, HighMass, LowMass2, MediumMass2, HighMass2 = galaxy_separation(mass)

'''for each in LowMass:
    average, radius = AverageFunctionPlotting(each, 15, 2)
    x = statistics.stdev(average)
    upperbound = []
    lowerbound = []
    for each in average: 
        upperbound.append(each + x)
        lowerbound.append(each - x)
    radius = np.delete(radius, -1)
    #plt.plot(radius, average, label = "Average")
    plt.legend(bbox_to_anchor=(1.05, 1.0),prop={'size': 7} ,loc='upper left')
    #plt.fill_between(radius, upperbound, lowerbound, color="lightblue",alpha=0.4)
    plt.figure()'''

average, radius, stddev ,upper, lower = AverageFunctionPlotting(HighMass2, 18, 1.2)
radius = np.delete(radius, -1)
plt.plot(radius,average, color = 'black', label = "Average")
#plt.title("Velocity of the bulge against radius")
plt.legend(bbox_to_anchor=(1.0, 1.0),prop={'size': 6}, ncol = 1 ,loc='upper left')
plt.fill_between(radius, upper, lower, color="grey",alpha=0.4)

plt.show()
